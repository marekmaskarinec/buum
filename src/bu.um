
import "std.um"

type Symbol = struct {
	exists: bool
	kind: enum{
		compile
		install
	}
}

type Target = enum(int32) {
    def
    linux
    linux_musl
    linux_glibc
    windows
    emscripten
}

type BuildData = struct {
	outFile: std::File
	targets: []Target
	targetToIndex: map[Target]int
	symbols: map[str]Symbol
	srcDir: str
	installDir: str
}

type Build* = struct {
	outPath: str
	defTarget: Target
	data: ^BuildData
}

type Compile* = struct {
	b: ^Build
	name: str
	kind: enum {
		umi
		exe
		sharedLib
		staticLib
	}
	// Only used for UMIs
	moduleName: str
}

type LazyPath* = struct {
	path: str
}

type RawString* = struct {
	s: str
}

fn (b: ^Build) fatal(s: str) {
	fprintf(std::stderr(), "fatal: %s\n", s)
	exit(1)
}

fn (b: ^Build) gen*(s: str) {
	fprintf(b.data.outFile, "%s\n", s);
}

fn (b: ^Build) genHeader*() {
	b.gen("const std = @import(\"std\");")
	// Zig is pretty annyoing with discards. If you discard a value,
	// but then use it later, it will produce an error.
	b.gen("fn __discard(v: *const anyopaque) void { _ = v; }")

	b.gen("const targets: []const std.Target.Query = &.{")
	for i,t in b.data.targets {
		b.data.targetToIndex[t] = i
		switch t {
		case .def: b.gen(".{},")
		case .linux: b.gen(".{ .os_tag = .linux, .abi = .musl },")
		case .linux_musl: b.gen(".{ .os_tag = .linux, .abi = .musl },")
		case .linux_glibc: b.gen(".{ .os_tag = .linux, .abi = .gnu },")
		case .windows: b.gen(".{ .os_tag = .windows },")
		case .emscripten: b.gen(".{ .os_tag = .emscripten },")
		}
	}
	b.gen("};")

	b.gen("const target_tags = [_][]const u8{")
	for i,t in b.data.targets {
		switch t {
		case .def: b.gen("\"\",")
		case .linux: b.gen("\"_linux\",")
		case .linux_musl: b.gen("\"_linux\",")
		case .linux_glibc: b.gen("\"_linux\",")
		case .windows: b.gen("\"_windows\",")
		case .emscripten: b.gen("\"_emscripten\",")
		}
	}
	b.gen("};")

	b.gen(
		"pub fn build(b: *std.Build) !void {\n" +
			"const optimize = b.standardOptimizeOption(.{});\n" +
			"for (targets, 0..) |target,i| {\n" +
			"  __discard(@ptrCast(&target));\n" +
			"  __discard(@ptrCast(&i));\n"
	)
}

fn (b: ^Build) genFooter*() {
	b.gen("}\n}")
}

fn (b: ^Build) sanitizeSymbolName*(n: str): bool {
	if len(n) == 0 { return false }

	isValidFirstChar := fn(c: char): bool {
		ci := int(c)
		return (ci >= int('a') && ci <= int('z')) || (ci >= int('A') && ci <= int('Z')) || c == '_'
	}

	isValidChar := fn(c: char): bool |isValidFirstChar| {
		ci := int(c)
		return isValidFirstChar(c) || (ci >= int('0') && ci <= int('9'))
	}

	if !isValidFirstChar(n[0]) { return false }

	for _,c in n {
		if !isValidChar(c) { return false }
	}

	return true
}

fn (b: ^Build) path*(p: str): LazyPath {
	return {p}
}

fn (b: ^Build) resolveSrcPath(p: str): str {
		if b.data.srcDir != "" {
			return b.data.srcDir + "/" + p
		}

		return p
}

fn (b: ^Build) resolveInstallPath(p: str): str {
		if b.data.installDir != "" {
			return b.data.installDir + "/" + p
		}

		return p
}

fn (b: ^Build) serialize(a: any): str {
	switch v := type(a) {
	case RawString: return v.s
	case LazyPath:
		return "b.path(" + b.serialize(b.resolveSrcPath(v.path)) + ")"
	case map[str]any:
		out := ".{"
		for k,e in v {
			out += "." + k + "=" + b.serialize(e) + ","
		}
		
		return out + "}"
	case str:
		out := ""
		// TODO: this is probably slow
		for _,c in v {
			if c == '"' { out += "\\\""
			} else if c == '\n' { out += "\\n"
			} else if c == '\t' { out += "\\t"
			} else if c == '\r' { out += "\\r"
			} else { out += str(c) }
		}
		return "\"" + out + "\""
	case []str:
		out := "&[_][]const u8{"
		for i,s in v {
			out += b.serialize(s)
		}
		return out + "}"
	case Compile:
		sym := b.data.symbols[v.name] 
		if !sym.exists { b.fatal("unknown Compile: " + v.name) }
		if sym.kind != .compile { b.fatal(v.name + " is not of type Compile") }
		return v.name
	}

	return sprintf("%v", a)
}

fn (b: ^Build) genCallEx(obj, fName: str, args: []any) {
	argsStr := ""
	for i,a in args {
		argsStr += b.serialize(a)
		if i < len(args) - 1 {
			argsStr += ", "
		}
	}

	b.gen(obj + "." + fName + "(" + argsStr + ");")
}

fn (b: ^Build) genCall(fName: str, args: ..any) {
	b.genCallEx("b", fName, args)
}

fn (b: ^Build) forTarget*(t: Target, f: fn(b: ^Build)) {
	if t == b.defTarget { t = .def }
	if !validkey(b.data.targetToIndex, t) { return }

	b.gen(sprintf("if (i == %d) {", b.data.targetToIndex[t]))
	f(b)
	b.gen("}")
}

fn (b: ^Build) forTargets*(targets: []Target, f: fn(b: ^Build)) {
	cond := ""
	for i,t in targets {
		if t == b.defTarget { t = .def }
		if !validkey(b.data.targetToIndex, t) { continue }
		cond += sprintf("i == %d", b.data.targetToIndex[t])
		if i < len(targets) - 1 { cond += " or " }
	}

	if len(cond) == 0 { return }

	b.gen("if (" + cond + ") {")
	f(b)
	b.gen("}")
}

fn (b: ^Build) include*(f: fn(b: ^Build), par: struct{
	srcDir: str
	installDir: str
}) {
	oldData := BuildData{}
	oldData = b.data^
	if b.data.srcDir == "" {
		b.data.srcDir = par.srcDir
	} else {
		b.data.srcDir += "/" + par.srcDir
	}

	if b.data.installDir == "" {
		b.data.installDir = par.installDir
	} else {
		b.data.installDir += "/" + par.installDir
	}

	b.gen("{")
	f(b)
	b.gen("}")
	b.data ^= oldData
}

// TODO: b.platStr

// TODO: b.includeZig

fn (c: ^Compile) genCall(fName: str, args: ..any) {
// TODO: Compile.install
	c.b.genCallEx(c.b.serialize(c^), fName, args)
}

fn (b: ^Build) addSharedLibrary*(name: str): Compile {
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name,
		kind: .sharedLib
	}

	// TODO: Solve optimize at higher level
	b.gen(sprintf("const %s = b.addSharedLibrary(.{.name = \"%s\",.target=b.resolveTargetQuery(target),.optimize=optimize,});", name, name))
	return c
}

fn (b: ^Build) addExecutable*(name: str): Compile {
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name,
		kind: .exe
	}

	// TODO: Solve optimize at higher level
	b.gen(sprintf("const %s = b.addExecutable(.{.name = \"%s\",.target=b.resolveTargetQuery(target),.optimize=optimize,});", name, name))
	return c
}

fn (b: ^Build) addStaticLibrary*(name: str): Compile {
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name,
		kind: .staticLib
	}

	// TODO: Solve optimize at higher level
	b.gen(sprintf("const %s = b.addStaticLibrary(.{.name = \"%s\",.target=b.resolveTargetQuery(target),.optimize=optimize,});", name, name))
	return c
}

fn (c: ^Compile) addAfterIncludePath*(path: LazyPath) {
	c.genCall("addAfterIncludePath", path)
}

fn (c: ^Compile) addAssemblyFile*(path: LazyPath) {
	c.genCall("addAssemblyFile", path)
}

fn (c: ^Compile) addCSourceFile*(path: LazyPath, flags: []str = {}) {
	c.genCall("addCSourceFile", map[str]any{ "file": path, "flags": flags })
}

fn (c: ^Compile) addFrameworkPath*(directory: LazyPath) {
	c.genCall("addFrameworkPath", directory)
}

fn (c: ^Compile) addIncludePath*(directory: LazyPath) {
	c.genCall("addIncludePath", directory)
}

fn (c: ^Compile) addLibraryPath*(directory: LazyPath) {
	c.genCall("addLibraryPath", directory)
}

fn (c: ^Compile) addObject*(object: Compile) {
	c.genCall("addObject", object)
}

fn (c: ^Compile) addObjectFile*(file: LazyPath) {
	c.genCall("addObjectFile", file)
}

fn (c: ^Compile) addSystemIncludePath*(directory: LazyPath) {
	c.genCall("addSystemIncludePath", directory)
}

fn (c: ^Compile) addSystemLibraryPath*(directory: LazyPath) {
	c.genCall("addSystemLibraryPath", directory)
}

fn (c: ^Compile) linkLibC*() {
	c.genCall("linkLibC")
}

fn (c: ^Compile) linkLibCpp*() {
	c.genCall("linkLibCpp")
}

fn (c: ^Compile) linkLibrary*(lib: Compile) {
	c.genCall("linkLibrary", lib)
}

fn (c: ^Compile) linkSystemLibrary*(name: str) {
	c.genCall("linkSystemLibrary", name)
}

fn (c: ^Compile) setExecCmd*(args: ..str) {
	c.genCall("setExecCmd", args)
}

fn (c: ^Compile) setVersionScript*(source: LazyPath) {
	c.genCall("setVersionScript", source)
}

fn (c: ^Compile) install*() {
	sym := c.name + "_install"
	if c.b.data.symbols[sym].exists { c.b.fatal("symbol exists: " + sym) }
	c.b.data.symbols[sym] = { exists: true, kind: .install }
	c.b.gen(sprintf("const %s = ", sym))
	var args: map[str]any

	switch (c.kind) {
	case .umi:
		args = map[str]any{
			"dest_sub_path": RawString{sprintf("try std.fmt.allocPrint(b.allocator, \"%s{s}.umi\", .{target_tags[i]})", c.moduleName)},
			"dylib_symlinks": false
		}
	}

	if c.b.data.installDir == ""{
		args["dest_dir"] = RawString{".{ .override = .prefix }"}
	} else {
		args["dest_dir"] = RawString{sprintf(".{ .override = .{ .custom = %s }}", c.b.serialize(c.b.data.installDir))}
	}
	c.b.genCall("addInstallArtifact", c, args)
	c.b.gen(sprintf("b.getInstallStep().dependOn(&%s.step);", sym))
}

type Module* = struct {
	b: ^Build
	name: str
	source: LazyPath
	umi: Compile
}

fn (b: ^Build) addModule*(source: LazyPath): Module {
	m := Module{}
	m.b = b
	m.source = source
	// TODO: Do this in zig helper function
	start := -1
	end := -1
	for i,c in source.path {
		if c == '/' {
			start = i
		}

		if c == '.' {
			end = i
		}
	}
	if (start < 0) { start = 0 }
	if (end < 0) { end = len(source.path) - 1 }
	
	m.name = slice(source.path, start, end)

	return m
}

fn (m: ^Module) addUMI*(): Compile {
	m.umi = m.b.addSharedLibrary(m.name + "_umi")
	m.umi.kind = .umi
	m.umi.moduleName = m.name
	m.umi.linkLibC();
	return m.umi
}

fn (m: ^Module) install*() {
	m.b.genCall("installFile",
		m.b.resolveSrcPath(m.source.path),
		m.b.resolveInstallPath(m.name + ".um")
	)

	if (m.umi.name == "") {
		return
	}

	m.umi.install()
}

fn umc__getTargets(T: ^void, out: ^[]Target)

fn __init*(b: ^Build): int {
	b.data = new(BuildData)

	if b.outPath == "" {
		b.data.outFile = std::stdout()
	} else {
		var err: std::Err
		b.data.outFile, err = std::fopen(b.outPath, "w")
		if err.code != 0 {
			return err.code
		}
	}

	umc__getTargets(typeptr([]Target), &b.data.targets)

	b.genHeader()

	return 0
}

fn __deinit*(b: ^Build): int {
	b.genFooter()

	if b.outPath != "" {
		err := std::fclose(b.data.outFile)
		if err.code != 0 {
			return err.code
		}
	}

	return 0
}
