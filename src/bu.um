
import "std.um"

type Symbol = struct {
	exists: bool
	kind: enum{
		compile
		install
	}
}

type BuildData = struct {
	outFile: std::File
	symbols: map[str]Symbol
	srcDir: str
	installDir: str
}

type Build* = struct {
	outPath: str
	data: ^BuildData
}

type Compile* = struct {
	b: ^Build
	name: str
}

type LazyPath* = struct {
	path: str
}

type RawString* = struct {
	s: str
}

fn (b: ^Build) fatal(s: str) {
	fprintf(std::stderr(), "fatal: %s\n", s)
	exit(1)
}

fn (b: ^Build) gen*(s: str) {
	fprintf(b.data.outFile, "%s\n", s);
}

fn (b: ^Build) genHeader*() {
	b.gen(
		"const std = @import(\"std\");\n" +

		"pub fn build(b: *std.Build) !void {\n" +
			"const target = b.standardTargetOptions(.{});\n" +
			"const optimize = b.standardOptimizeOption(.{});"
	)
}

fn (b: ^Build) genFooter*() {
	b.gen("}")
}

fn (b: ^Build) sanitizeSymbolName*(n: str): bool {
	if len(n) == 0 { return false }

	isValidFirstChar := fn(c: char): bool {
		ci := int(c)
		return (ci >= int('a') && ci <= int('z')) || (ci >= int('A') && ci <= int('Z')) || c == '_'
	}

	isValidChar := fn(c: char): bool |isValidFirstChar| {
		ci := int(c)
		return isValidFirstChar(c) || (ci >= int('0') && ci <= int('9'))
	}

	if !isValidFirstChar(n[0]) { return false }

	for _,c in n {
		if !isValidChar(c) { return false }
	}

	return true
}

fn (b: ^Build) path*(p: str): LazyPath {
	return {p}
}

fn (b: ^Build) resolveSrcPath(p: str): str {
		if b.data.srcDir != "" {
			return b.data.srcDir + "/" + p
		}

		return p
}

fn (b: ^Build) resolveInstallPath(p: str): str {
		if b.data.installDir != "" {
			return b.data.installDir + "/" + p
		}

		return p
}

fn (b: ^Build) serialize(a: any): str {
	switch v := type(a) {
	case RawString: return v.s
	case LazyPath:
		return "b.path(" + b.serialize(b.resolveSrcPath(v.path)) + ")"
	case map[str]any:
		out := ".{"
		for k,e in v {
			out += "." + k + "=" + b.serialize(e) + ","
		}
		
		return out + "}"
	case str:
		out := ""
		// TODO: this is probably slow
		for _,c in v {
			if c == '"' { out += "\\\""
			} else if c == '\n' { out += "\\n"
			} else if c == '\t' { out += "\\t"
			} else if c == '\r' { out += "\\r"
			} else { out += str(c) }
		}
		return "\"" + out + "\""
	case []str:
		out := "&[_][]const u8{"
		for s in v {
			out += b.serialize(s)
		}
		return out + "}"
	case Compile:
		sym := b.data.symbols[v.name] 
		if !sym.exists { b.fatal("unknown Compile: " + v.name) }
		if sym.kind != .compile { b.fatal(v.name + " is not of type Compile") }
		return v.name
	}

	return sprintf("%v", a)
}

fn (b: ^Build) genCallEx(obj, fName: str, args: []any) {
	argsStr := ""
	for i,a in args {
		argsStr += b.serialize(a)
		if i < len(args) - 1 {
			argsStr += ", "
		}
	}

	b.gen(obj + "." + fName + "(" + argsStr + ");")
}

fn (b: ^Build) genCall(fName: str, args: ..any) {
	b.genCallEx("b", fName, args)
}

fn (b: ^Build) include*(f: fn(b: ^Build), par: struct{
	srcDir: str
	installDir: str
}) {
	oldData := BuildData{}
	oldData = b.data^
	if b.data.srcDir == "" {
		b.data.srcDir = par.srcDir
	} else {
		b.data.srcDir += "/" + par.srcDir
	}

	if b.data.installDir == "" {
		b.data.installDir = par.installDir
	} else {
		b.data.installDir += "/" + par.installDir
	}

	b.gen("{")
	f(b)
	b.gen("}")
	b.data ^= oldData
}

// TODO: b.platStr

// TODO: b.includeZig

fn (c: ^Compile) genCall(fName: str, args: ..any) {
	c.b.genCallEx(c.b.serialize(c^), fName, args)
}

fn (b: ^Build) addSharedLibrary*(name: str): Compile {
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name
	}

	// TODO: Solve target and optimize at higher level
	b.gen(sprintf("const %s = b.addSharedLibrary(.{.name = \"%s\",.target=target,.optimize=optimize,});", name, name))
	return c
}

fn (c: ^Compile) addAfterIncludePath*(path: LazyPath) {
	c.genCall("addAfterIncludePath", path)
}

fn (c: ^Compile) addAssemblyFile*(path: LazyPath) {
	c.genCall("addAssemblyFile", path)
}

fn (c: ^Compile) addCSourceFile*(path: LazyPath, flags: []str = {}) {
	c.genCall("addCSourceFile", map[str]any{ "file": path, "flags": flags })
}

fn (c: ^Compile) addFrameworkPath*(directory: LazyPath) {
	c.genCall("addFrameworkPath", directory)
}

fn (c: ^Compile) addIncludePath*(directory: LazyPath) {
	c.genCall("addIncludePath", directory)
}

fn (c: ^Compile) addLibraryPath*(directory: LazyPath) {
	c.genCall("addLibraryPath", directory)
}

fn (c: ^Compile) addObject*(object: Compile) {
	c.genCall("addObject", object)
}

fn (c: ^Compile) addObjectFile*(file: LazyPath) {
	c.genCall("addObjectFile", file)
}

fn (c: ^Compile) addSystemIncludePath*(directory: LazyPath) {
	c.genCall("addSystemIncludePath", directory)
}

fn (c: ^Compile) addSystemLibraryPath*(directory: LazyPath) {
	c.genCall("addSystemLibraryPath", directory)
}

fn (c: ^Compile) linkLibC*() {
	c.genCall("linkLibC")
}

fn (c: ^Compile) linkLibCpp*() {
	c.genCall("linkLibCpp")
}

fn (c: ^Compile) linkLibrary*(lib: Compile) {
	c.genCall("linkLibrary", lib)
}

fn (c: ^Compile) linkSystemLibrary*(name: str) {
	c.genCall("linkSystemLibrary")
}

fn (c: ^Compile) setExecCmd*(args: ..str) {
	c.genCall("setExecCmd", args)
}

fn (c: ^Compile) setVersionScript*(source: LazyPath) {
	c.genCall("setVersionScript", source)
}

type Module* = struct {
	b: ^Build
	name: str
	source: LazyPath
	umi: Compile
}

fn (b: ^Build) addModule*(source: LazyPath): Module {
	m := Module{}
	m.b = b
	m.source = source
	// TODO: Do this in zig helper function
	start := -1
	end := -1
	for i,c in source.path {
		if c == '/' {
			start = i
		}

		if c == '.' {
			end = i
		}
	}
	if (start < 0) { start = 0 }
	if (end < 0) { end = len(source.path) - 1 }
	
	m.name = slice(source.path, start, end)

	return m
}

fn (m: ^Module) addUMI*(): Compile {
	m.umi = m.b.addSharedLibrary(m.name + "_umi")
	m.umi.linkLibC();
	return m.umi
}

fn (m: ^Module) install*() {
	m.b.genCall("installFile",
		m.b.resolveSrcPath(m.source.path),
		m.b.resolveInstallPath(m.name + ".um")
	)

	if (m.umi.name == "") {
		return
	}

	sym := sprintf("%s_umi_install", m.name)
	if m.b.data.symbols[sym].exists { m.b.fatal("symbol exists: " + sym) }
	m.b.data.symbols[sym] = { exists: true, kind: .install }
	m.b.gen(sprintf("const %s = ", sym))
	args := map[str]any{
		"dest_sub_path": m.name + ".umi",
		"dylib_symlinks": false
	}
	if m.b.data.installDir == ""{
		args["dest_dir"] = RawString{".{ .override = .prefix }"}
	} else {
		args["dest_dir"] = RawString{sprintf(".{ .override = .{ .custom = %s }}", m.b.serialize(m.b.data.installDir))}
	}
	m.b.genCall("addInstallArtifact", m.umi, args)
	m.b.gen("b.getInstallStep().dependOn(&os_umi_install.step);")
}

fn __init*(b: ^Build): int {
	b.data = new(BuildData)

	if b.outPath == "" {
		b.data.outFile = std::stdout()
	} else {
		var err: std::Err
		b.data.outFile, err = std::fopen(b.outPath, "w")
		if err.code != 0 {
			return err.code
		}
	}

	b.genHeader()

	return 0
}

fn __deinit*(b: ^Build): int {
	b.genFooter()

	if b.outPath != "" {
		err := std::fclose(b.data.outFile)
		if err.code != 0 {
			return err.code
		}
	}

	return 0
}
