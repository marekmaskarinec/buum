//~~bu.um
// > NOTE: This module contains other exported functions for low-level access
// > to the generation API, which are not documented here.
//~~

import "std.um"

g_symbolCounter := 0

type Symbol = struct {
	exists: bool
	kind: enum{
		compile
		run
		install
		lazyPath
	}
}

//~~type Target
type Target* = enum(int32) {
    def
    linux
    linux_musl
    linux_glibc
    windows
    emscripten
}
//~~

//~~type SourceFileLanguage
// Type of file passed to `addCSourceFile`.
type SourceFileLanguage* = enum {
	auto
	c
	cpp
	objective_c
	objective_cpp
	assembly
	assembly_with_preprocessor
}
//~~

fn (lang: ^SourceFileLanguage) toStr*(): str {
	switch (lang^) {
	case .auto: return "null"
	case .c: return ".c"
	case .cpp: return ".cpp"
	case .objective_c: return ".objective_c"
	case .objective_cpp: return ".objective_cpp"
	case .assembly: return ".assembly"
	case .assembly_with_preprocessor: return ".assembly_with_preprocessor"
	}
	return ""
}

type BuildData = struct {
	outFile: std::File
	targets: []Target
	targetToIndex: map[Target]int
	symbols: map[str]Symbol
	srcDir: str
	installDir: str
	cacheDir: str
}

//~~type Build
type Build* = struct {
//}
//~~
	outPath: str
	cacheDir: str
	defTarget: Target
	data: ^BuildData
}

//~~type Compile
type Compile* = struct {
//}
//~~
	b: ^Build
	name: str
	kind: enum {
		umi
		exe
		sharedLib
		staticLib
	}
	// Only used for UMIs
	moduleName: str
}

//~~type Run
type Run* = struct {
//}	
//~~
	b: ^Build
	name: str
}

//~~type LazyPath
// Represents a path in the source directory.
type LazyPath* = struct {
	path: str
	symbol: bool
}
//~~

//~~type RawString
// String directly output to the generated build.zig
type RawString* = struct {
	s: str
}
//~~

g_test := false
g_hadError := false
//~~fn Build.fatal
// Stops the build process with a message.
fn (b: ^Build) fatal*(s: str) {
//~~
	if g_test {
		g_hadError = true
	} else {
		fprintf(std::stderr(), "fatal: %s\n", s)
		exit(1)
	}
}

g_genOutput := ""
fn (b: ^Build) gen*(s: str) {
	if g_test {
		g_genOutput += sprintf("%s\n", s)
	} else {
		fprintf(b.data.outFile, "%s\n", s)
	}
}

fn (b: ^Build) genDiscard(sym: str) {
	b.gen(sprintf("__discard(@ptrCast(&%s));", sym))
}

fn (b: ^Build) genHeader() {
	b.gen("const std = @import(\"std\");")
	// Zig is pretty annyoing with discards. If you discard a value,
	// but then use it later, it will produce an error.
	b.gen("fn __discard(v: *const anyopaque) void { _ = v; }")

	b.gen("const targets: []const std.Target.Query = &.{")
	for i,t in b.data.targets {
		b.data.targetToIndex[t] = i
		switch t {
		case .def: b.gen(".{},")
		case .linux: b.gen(".{ .os_tag = .linux, .abi = .musl },")
		case .linux_musl: b.gen(".{ .os_tag = .linux, .abi = .musl },")
		case .linux_glibc: b.gen(".{ .os_tag = .linux, .abi = .gnu },")
		case .windows: b.gen(".{ .os_tag = .windows },")
		case .emscripten: b.gen(".{ .os_tag = .emscripten },")
		}
	}
	b.gen("};")

	b.gen("const target_tags = [_][]const u8{")
	for i,t in b.data.targets {
		switch t {
		case .def: b.gen("\"\",")
		case .linux: b.gen("\"_linux\",")
		case .linux_musl: b.gen("\"_linux\",")
		case .linux_glibc: b.gen("\"_linux\",")
		case .windows: b.gen("\"_windows\",")
		case .emscripten: b.gen("\"_emscripten\",")
		}
	}
	b.gen("};")

	b.gen(
		"pub fn build(b: *std.Build) !void {\n" +
			"const optimize = b.standardOptimizeOption(.{});\n" +
			"for (targets, 0..) |target,i| {\n" +
			"  __discard(@ptrCast(&target));\n" +
			"  __discard(@ptrCast(&optimize));\n" +
			"  __discard(@ptrCast(&i));\n"
	)
}

fn (b: ^Build) genFooter() {
	b.gen("}\n}")
}

fn (b: ^Build) sanitizeSymbolName*(n: str): bool {
	if len(n) == 0 { return false }

	isValidFirstChar := fn(c: char): bool {
		ci := int(c)
		return (ci >= int('a') && ci <= int('z')) || (ci >= int('A') && ci <= int('Z')) || c == '_'
	}

	isValidChar := fn(c: char): bool |isValidFirstChar| {
		ci := int(c)
		return isValidFirstChar(c) || (ci >= int('0') && ci <= int('9'))
	}

	if !isValidFirstChar(n[0]) { return false }

	for _,c in n {
		if !isValidChar(c) { return false }
	}

	return true
}

//~~fn Build.path
// Returns a LazyPath
fn (b: ^Build) path*(p: str): LazyPath {
//~~
	return {path: p, symbol: false}
}

fn (b: ^Build) resolveSrcPath(p: str): str {
		if b.data.srcDir != "" {
			return b.data.srcDir + "/" + p
		}

		return p
}

fn (b: ^Build) resolveInstallPath(p: str): str {
		if b.data.installDir != "" {
			return b.data.installDir + "/" + p
		}

		return p
}

fn (b: ^Build) serialize(a: any): str {
	switch v := type(a) {
	case RawString: return v.s
	case SourceFileLanguage: return v.toStr()
	case LazyPath:
		if v.symbol {
			return v.path
		}
		return "b.path(" + b.serialize(b.resolveSrcPath(v.path)) + ")"
	case map[str]any:
		out := ".{"
		for k,e in v {
			out += "." + k + "=" + b.serialize(e) + ","
		}
		
		return out + "}"
	case str:
		out := ""
		// TODO: this is probably slow
		for _,c in v {
			if c == '"' { out += "\\\""
			} else if c == '\n' { out += "\\n"
			} else if c == '\t' { out += "\\t"
			} else if c == '\r' { out += "\\r"
			} else if c == '\\' { out += "\\\\"
			} else { out += str(c) }
		}
		return "\"" + out + "\""
	case []str:
		out := "&[_][]const u8{"
		for i,s in v {
			out += b.serialize(s) + ","
		}
		return out + "}"
	case Compile:
		sym := b.data.symbols[v.name] 
		if !sym.exists { b.fatal("unknown Compile: " + v.name) }
		if sym.kind != .compile { b.fatal(v.name + " is not of type Compile") }
		return v.name
	case Run:
		sym := b.data.symbols[v.name] 
		if !sym.exists { b.fatal("unknown Run: " + v.name) }
		if sym.kind != .run { b.fatal(v.name + " is not of type Run") }
		return v.name
	}

	return sprintf("%v", a)
}

fn (b: ^Build) genCallEx(obj, fName: str, args: []any) {
	argsStr := ""
	for i,a in args {
		argsStr += b.serialize(a)
		if i < len(args) - 1 {
			argsStr += ", "
		}
	}

	b.gen(obj + "." + fName + "(" + argsStr + ");")
}

fn (b: ^Build) genCall(fName: str, args: ..any) {
	b.genCallEx("b", fName, args)
}

//~~fn Build.forTarget
// Runs a function only if compiling for target `t`.
fn (b: ^Build) forTarget*(t: Target, f: fn(b: ^Build)) {
//~~
	if t == b.defTarget { t = .def }
	if !validkey(b.data.targetToIndex, t) { return }

	b.gen(sprintf("if (i == %d) {", b.data.targetToIndex[t]))
	f(b)
	b.gen("}")
}

//~~fn Build.forTargets
// Runs a function only if compiling for any of the targets. If a building
// for multiple targets, the function will be run for each of them.
fn (b: ^Build) forTargets*(targets: []Target, f: fn(b: ^Build)) {
//~~
	cond := ""
	for i,t in targets {
		if t == b.defTarget { t = .def }
		if !validkey(b.data.targetToIndex, t) { continue }
		cond += sprintf("i == %d", b.data.targetToIndex[t])
		if i < len(targets) - 1 { cond += " or " }
	}

	if len(cond) == 0 { return }

	b.gen("if (" + cond + ") {")
	f(b)
	b.gen("}")
}

//~~fn Build.include
// Includes another build function in this build. The source and output
// directories can be parametrized.
fn (b: ^Build) include*(f: fn(b: ^Build), par: struct{
	srcDir: str
	installDir: str
}) {
//~~
// TODO: This recursion doesn't seem to be all that correct
	oldData := BuildData{}
	oldData = b.data^
	if b.data.srcDir == "" {
		b.data.srcDir = par.srcDir
	} else {
		b.data.srcDir += "/" + par.srcDir
	}

	if b.data.installDir == "" {
		b.data.installDir = par.installDir
	} else {
		b.data.installDir += "/" + par.installDir
	}

	b.gen("{")
	f(b)
	b.gen("}")
	b.data ^= oldData
}

//~~fn Build.addInstallDirectory
// Installs a directory `sourceDir` to `installDir`
//
// * `excludeExtensions` - if not empty excludes extensions in this array
// * `includeExtensions` - if not empty, installs only files with extensions in this array
fn (b: ^Build) addInstallDirectory*(options: struct {
	sourceDir: LazyPath
	installDir: str
	excludeExtensions: []str
	includeExtensions: []str
}) {
//~~
	opts := map[str]any{}
	opts["source_dir"] = options.sourceDir
	opts["install_dir"] = map[str]any{ "custom": options.installDir }
	opts["install_subdir"] = ""
	if len(options.excludeExtensions) > 0 {
		opts["exclude_extensions"] = options.excludeExtensions
		opts["include_extensions"] = options.includeExtensions
	}

	b.gen("b.getInstallStep().dependOn(&b.addInstallDirectory(" + b.serialize(opts) + ").step);")
}

//~~fn Build.addInstallFile
// Installs a file `source` to path `dest`. `dest` *must* be a full path to
// the resulting file (not a directory).
fn (b: ^Build) addInstallFile*(source: LazyPath, dest: str) {
//~~
	if dest == "" {
		b.fatal("destination path cannot be empty")
	}
	b.gen("b.getInstallStep().dependOn(&b.addInstallFile(" + b.serialize(source) + ", " + b.serialize(dest) + ").step);")
}

// TODO: b.platStr

// TODO: b.includeZig

fn (c: ^Compile) genCall(fName: str, args: ..any) {
// TODO: Compile.install
	c.b.genCallEx(c.b.serialize(c^), fName, args)
}

//~~fn Build.addSharedLibrary
// Creates a shared library.
//
// > NOTE: The library has to be installed with the `Compile.install` method.
fn (b: ^Build) addSharedLibrary*(name: str): Compile {
//~~
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name,
		kind: .sharedLib
	}

	// TODO: Solve optimize at higher level
	b.gen(sprintf("const %s = b.addSharedLibrary(.{.name = \"%s\",.target=b.resolveTargetQuery(target),.optimize=optimize,});", name, name))
	b.genDiscard(name)
	c.genCall("addSystemIncludePath", RawString{ ".{ .cwd_relative = " + b.serialize(b.data.cacheDir) + "}" })
	return c
}

//~~fn Build.addExecutable
// Creates an executable.
//
// > NOTE: The executable has to be installed with the `Compile.install` method.
fn (b: ^Build) addExecutable*(name: str): Compile {
//~~
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name,
		kind: .exe
	}

	// TODO: Solve optimize at higher level
	b.gen(sprintf("const %s = b.addExecutable(.{.name = \"%s\",.target=b.resolveTargetQuery(target),.optimize=optimize,});", name, name))
	b.genDiscard(name)
	c.genCall("addSystemIncludePath", RawString{ ".{ .cwd_relative = " + b.serialize(b.data.cacheDir) + "}" })
	return c
}

//~~fn Build.addStaticLibrary
// Creates a shared library.
//
// > NOTE: The library has to be installed with the `Compile.install` method.
fn (b: ^Build) addStaticLibrary*(name: str): Compile {
//~~
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.symbols[name].exists {
		b.fatal("name already used: " + name)
	}

	b.data.symbols[name] = {
		exists: true,
		kind: .compile
	}

	c := Compile{
		b: b,
		name: name,
		kind: .staticLib
	}

	// TODO: Solve optimize at higher level
	b.gen(sprintf("const %s = b.addStaticLibrary(.{.name = \"%s\",.target=b.resolveTargetQuery(target),.optimize=optimize,});", name, name))
	b.genDiscard(name)
	c.genCall("addSystemIncludePath", RawString{ ".{ .cwd_relative = " + b.serialize(b.data.cacheDir) + "}" })
	return c
}

//~~fn Compile.addAfterIncludePath
fn (c: ^Compile) addAfterIncludePath*(path: LazyPath) {
//~~
	c.genCall("addAfterIncludePath", path)
}

//~~fn Compile.addAssemblyFile
fn (c: ^Compile) addAssemblyFile*(path: LazyPath) {
//~~
	c.genCall("addAssemblyFile", path)
}

//~~fn Compile.addCSourceFile
fn (c: ^Compile) addCSourceFile*(path: LazyPath, flags: []str = {}, language: SourceFileLanguage = .auto) {
//~~
	c.genCall("addCSourceFile", map[str]any{ "file": path, "flags": flags, "language": language })
}

//~~fn Compile.addFrameworkPath
fn (c: ^Compile) addFrameworkPath*(directory: LazyPath) {
//~~
	c.genCall("addFrameworkPath", directory)
}

//~~fn Compile.addAfterIncludePath
fn (c: ^Compile) addIncludePath*(directory: LazyPath) {
//~~
	c.genCall("addIncludePath", directory)
}

//~~fn Compile.addLibraryPath
fn (c: ^Compile) addLibraryPath*(directory: LazyPath) {
//~~
	c.genCall("addLibraryPath", directory)
}

//~~fn Compile.addObject
fn (c: ^Compile) addObject*(object: Compile) {
//~~
	c.genCall("addObject", object)
}

//~~fn Compile.addObjectFile
fn (c: ^Compile) addObjectFile*(file: LazyPath) {
//~~
	c.genCall("addObjectFile", file)
}

//~~fn Compile.addSystemIncludePath
fn (c: ^Compile) addSystemIncludePath*(directory: LazyPath) {
//~~
	c.genCall("addSystemIncludePath", directory)
}

//~~fn Compile.addSystemLibraryPath
fn (c: ^Compile) addSystemLibraryPath*(directory: LazyPath) {
//~~
	c.genCall("addSystemLibraryPath", directory)
}

//~~fn Compile.linkLibC
fn (c: ^Compile) linkLibC*() {
//~~
	c.genCall("linkLibC")
}

//~~fn Compile.linkLibCpp
fn (c: ^Compile) linkLibCpp*() {
//~~
	c.genCall("linkLibCpp")
}

//~~fn Compile.linkLibrary
fn (c: ^Compile) linkLibrary*(lib: Compile) {
//~~
	c.genCall("linkLibrary", lib)
}

//~~fn Compile.linkSystemLibrary
fn (c: ^Compile) linkSystemLibrary*(name: str) {
//~~
	c.genCall("linkSystemLibrary", name)
}

//~~fn Compile.setExecCmd
fn (c: ^Compile) setExecCmd*(args: ..str) {
//~~
	c.genCall("setExecCmd", args)
}

//~~fn Compile.setVersionScript
fn (c: ^Compile) setVersionScript*(source: LazyPath) {
//~~
	c.genCall("setVersionScript", source)
}

fn (c: ^Compile) addFileDependency*(source: LazyPath) {
	c.b.genCallEx(c.name+".root_module", "addAnonymousImport", {
		sprintf("anonymousImport_%d", g_symbolCounter),
		map[str]any{"root_module": source}
	})
	g_symbolCounter++
}

//~~fn Compile.install
fn (c: ^Compile) install*() {
//~~
	sym := c.name + "_install"
	if c.b.data.symbols[sym].exists { c.b.fatal("symbol exists: " + sym) }
	c.b.data.symbols[sym] = { exists: true, kind: .install }
	c.b.gen(sprintf("const %s = ", sym))
	var args: map[str]any

	switch (c.kind) {
	case .umi:
		args = map[str]any{
			"dest_sub_path": RawString{sprintf("try std.fmt.allocPrint(b.allocator, \"%s{s}.umi\", .{target_tags[i]})", c.moduleName)},
			"dylib_symlinks": false
		}
	}

	if c.b.data.installDir == ""{
		args["dest_dir"] = RawString{".{ .override = .prefix }"}
	} else {
		args["dest_dir"] = RawString{sprintf(".{ .override = .{ .custom = %s }}", c.b.serialize(c.b.data.installDir))}
	}
	c.b.genCall("addInstallArtifact", c, args)
	c.b.gen(sprintf("b.getInstallStep().dependOn(&%s.step);", sym))
}

//~~fn addSystemCommand
// Runs a system command during the install step.
fn (b: ^Build) addSystemCommand*(argv: ..str): Run {
//~~
	name := sprintf("systemCommand_%d", g_symbolCounter)
	g_symbolCounter++
	b.data.symbols[name] = {
		exists: true,
		kind: .run
	}

	r := Run {
		b: b,
		name: name
	}

	b.gen(sprintf("const %s = b.addSystemCommand(%s);", name, b.serialize(argv)))

	return r
}

fn (r: ^Run) genCall*(fName: str, args: ..any) {
	r.b.genCallEx(r.b.serialize(r^), fName, args)
}

//~~fn Run.addArgs
// Add a list of arguments to a run command.
fn (r: ^Run) addArgs*(argv: ..str) {
//~~
	r.genCall("addArgs", argv)
}

//~~fn Run.addFileArg
// Add an argument to a run command. The path is understood as an
// input file to the command. If the file changes, the command will
// be re-run.
fn (r: ^Run) addFileArg*(path: LazyPath) {
//~~
	r.genCall("addFileArg", path)
}

//~~fn Run.addOutputFileArg
// Add an argument to a run command. The argument is understood as the output
// file of the command. Returns a `LazyPath` representing the file.
fn (r: ^Run) addOutputFileArg*(path: str): LazyPath {
//~~
	name := sprintf("%s_outputFile_%d", r.name, g_symbolCounter)
	g_symbolCounter++
	r.b.data.symbols[name] = {
		exists: true,
		kind: .lazyPath
	}

	r.b.gen(sprintf("const %s = ", name))
	r.genCall("addOutputFileArg", path)
	r.b.genDiscard(name)

	return {
		symbol: true,
		path: name
	}
}

//~~fn Run.captureStdout
// Caputures the command stdout. Returns a `LazyPath`, which references a file
// containing the captured output.
fn (r: ^Run) captureStdout*(): LazyPath {
//~~
	name := sprintf("%s_outputFile_%d", r.name, g_symbolCounter)
	g_symbolCounter++
	r.b.data.symbols[name] = {
		exists: true,
		kind: .lazyPath
	}

	r.b.gen(sprintf("const %s = ", name))
	r.genCall("captureStdOut")
	r.b.genDiscard(name)

	return {
		symbol: true,
		path: name
	}
}

//~~type Module
type Module* = struct {
//~~
	b: ^Build
	name: str
	source: LazyPath
	umi: Compile
}

//~~fn addModule
// Creates an umka module.
//
// > NOTE: The module has to be installed with the `Module.install` method.
fn (b: ^Build) addModule*(source: LazyPath): Module {
//~~
	m := Module{}
	m.b = b
	m.source = source
	// TODO: Do this in zig helper function
	start := -1
	end := -1
	for i,c in source.path {
		if c == '/' {
			start = i
		}

		if c == '.' {
			end = i
		}
	}
	if (start < 0) { start = 0 }
	if (end < 0) { end = len(source.path) - 1 }
	
	m.name = slice(source.path, start, end)

	return m
}

//~~fn Module.addUMI
// Add an UMI library to the module and return its Compile struct. The library
// is installed automatically with the module.
fn (m: ^Module) addUMI*(): Compile {
//~~
	m.umi = m.b.addSharedLibrary(m.name + "_umi")
	m.umi.kind = .umi
	m.umi.moduleName = m.name
	m.umi.linkLibC();
	return m.umi
}

//~~fn Module.install
// Install the module and its UMI (if any).
fn (m: ^Module) install*() {
//~~
	m.b.genCall("installFile",
		m.b.resolveSrcPath(m.source.path),
		m.b.resolveInstallPath(m.name + ".um")
	)

	if (m.umi.name == "") {
		return
	}

	m.umi.install()
}

fn umc__getTargets(T: ^void, out: ^[]Target)

fn __init*(b: ^Build): int {
	b.data = new(BuildData)
	b.data.cacheDir = b.cacheDir

	if b.outPath == "" {
		b.data.outFile = std::stdout()
	} else {
		var err: std::Err
		b.data.outFile, err = std::fopen(b.outPath, "w")
		if err.code != 0 {
			return err.code
		}
	}

	umc__getTargets(typeptr([]Target), &b.data.targets)

	b.genHeader()

	return 0
}

fn __deinit*(b: ^Build): int {
	b.genFooter()

	if b.outPath != "" {
		err := std::fclose(b.data.outFile)
		if err.code != 0 {
			return err.code
		}
	}

	return 0
}
