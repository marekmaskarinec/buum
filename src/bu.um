
import "std.um"

type BuildData = struct {
	outFile: std::File
	compileNames: map[str]bool
}

type Build* = struct {
	outPath: str
	data: ^BuildData
}

type Compile* = struct {
	b: ^Build
	name: str
}

type LazyPath* = struct {
	path: str
}

type RawString* = struct {
	s: str
}

fn (p: ^LazyPath) get*(): str {
	return "b.path(\"" + p.path + "\")"
}

fn (b: ^Build) fatal(s: str) {
	fprintf(std::stderr(), "fatal: %s\n", s)
	exit(1)
}

fn (b: ^Build) gen*(s: str) {
	fprintf(b.data.outFile, "%s\n", s);
}

fn (b: ^Build) genHeader*() {
	b.gen(
		"const std = @import(\"std\");\n" +

		"pub fn build(b: *std.Build) !void {\n" +
			"const target = b.standardTargetOptions(.{});\n" +
			"const optimize = b.standardOptimizeOption(.{});"
	)
}

fn (b: ^Build) genFooter*() {
	b.gen("}")
}

fn (b: ^Build) sanitizeSymbolName*(n: str): bool {
	if len(n) == 0 { return false }

	isValidFirstChar := fn(c: char): bool {
		ci := int(c)
		return (ci >= int('a') && ci <= int('z')) || (ci >= int('A') && ci <= int('Z')) || c == '_'
	}

	isValidChar := fn(c: char): bool |isValidFirstChar| {
		ci := int(c)
		return isValidFirstChar(c) || (ci >= int('0') && ci <= int('9'))
	}

	if !isValidFirstChar(n[0]) { return false }

	for _,c in n {
		if !isValidChar(c) { return false }
	}

	return true
}

fn (b: ^Build) path*(p: str): LazyPath {
	return {p}
}

fn (b: ^Build) serialize(a: any): str {
	switch v := type(a) {
	case RawString: return v.s
	case LazyPath: return "b.path(" + b.serialize(v.path) + ")"
	case map[str]any:
		out := ".{"
		for k,e in v {
			out += "." + k + "=" + b.serialize(e) + ","
		}
		
		return out + "}"
	case str:
		// TODO: properly escape
		return "\"" + v + "\""
	case []str:
		out := "&[_][]const u8{"
		for s in v {
			out += b.serialize(s)
		}
		return out + "}"
	case Compile:
		if !b.data.compileNames[v.name] { b.fatal("unknown Compile: " + v.name) }
		return v.name
	}

	return sprintf("%v", a)
}

fn (b: ^Build) genCallEx(obj, fName: str, args: []any) {
	argsStr := ""
	for i,a in args {
		argsStr += b.serialize(a)
		if i < len(args) - 1 {
			argsStr += ", "
		}
	}

	b.gen(obj + "." + fName + "(" + argsStr + ");")
}

fn (b: ^Build) genCall(fName: str, args: ..any) {
	b.genCallEx("b", fName, args)
}


// TODO: Some kind of b.chDir(dir: str, cmd: fn(b: ^Build))

// TODO: b.platStr

// TODO: b.includeZig

fn (c: ^Compile) genCall(fName: str, args: ..any) {
	c.b.genCallEx(c.b.serialize(c^), fName, args)
}

fn (b: ^Build) addSharedLibrary*(name: str): Compile {
	if !b.sanitizeSymbolName(name) {
		b.fatal("invalid symbol name: " + name)
	}
	if b.data.compileNames[name] {
		b.fatal("name already used: " + name)
	}

	b.data.compileNames[name] = true

	c := Compile{
		b: b,
		name: name
	}

	// TODO: Solve target and optimize at higher level
	b.gen(sprintf("const %s = b.addSharedLibrary(.{.name = \"%s\",.target=target,.optimize=optimize,});", name, name))
	return c
}

fn (c: ^Compile) addAfterIncludePath*(path: LazyPath) {
	c.genCall("addAfterIncludePath", path)
}

fn (c: ^Compile) addAssemblyFile*(path: LazyPath) {
	c.genCall("addAssemblyFile", path)
}

fn (c: ^Compile) addCSourceFile*(path: LazyPath, flags: []str = {}) {
	c.genCall("addCSourceFile", map[str]any{ "file": path, "flags": flags })
}

fn (c: ^Compile) addFrameworkPath*(directory: LazyPath) {
	c.genCall("addFrameworkPath", directory)
}

fn (c: ^Compile) addIncludePath*(directory: LazyPath) {
	c.genCall("addIncludePath", directory)
}

fn (c: ^Compile) addLibraryPath*(directory: LazyPath) {
	c.genCall("addLibraryPath", directory)
}

fn (c: ^Compile) addObject*(object: Compile) {
	c.genCall("addObject", object)
}

fn (c: ^Compile) addObjectFile*(file: LazyPath) {
	c.genCall("addObjectFile", file)
}

fn (c: ^Compile) addSystemIncludePath*(directory: LazyPath) {
	c.genCall("addSystemIncludePath", directory)
}

fn (c: ^Compile) addSystemLibraryPath*(directory: LazyPath) {
	c.genCall("addSystemLibraryPath", directory)
}

fn (c: ^Compile) linkLibC*() {
	c.genCall("linkLibC")
}

fn (c: ^Compile) linkLibCpp*() {
	c.genCall("linkLibCpp")
}

fn (c: ^Compile) linkLibrary*(lib: Compile) {
	c.genCall("linkLibrary", lib)
}

fn (c: ^Compile) linkSystemLibrary*(name: str) {
	c.genCall("linkSystemLibrary")
}

fn (c: ^Compile) setExecCmd*(args: ..str) {
	c.genCall("setExecCmd", args)
}

fn (c: ^Compile) setVersionScript*(source: LazyPath) {
	c.genCall("setVersionScript", source)
}

type Module* = struct {
	b: ^Build
	name: str
	source: LazyPath
	umi: Compile
}

fn (b: ^Build) addModule*(source: LazyPath): Module {
	m := Module{}
	m.b = b
	m.source = source
	// TODO: Do this in zig helper function
	start := -1
	end := -1
	for i,c in source.path {
		if c == '/' {
			start = i
		}

		if c == '.' {
			end = i
		}
	}
	if (start < 0) { start = 0 }
	if (end < 0) { end = len(source.path) - 1 }
	
	m.name = slice(source.path, start, end)

	return m
}

fn (m: ^Module) addUMI*(): Compile {
	m.umi = m.b.addSharedLibrary(m.name + "_umi")
	m.umi.linkLibC();
	return m.umi
}

fn (m: ^Module) install*(subDir: str = ".") {
	m.b.genCall("installFile", m.source.path, subDir + "/" + m.name + ".um")

	if (m.umi.name == "") {
		return
	}

	// TODO: implement proper symbol checking for all types
	m.b.gen(sprintf("const %s_umi_install = ", m.name))
	args := map[str]any{
		"dest_sub_path": m.name + ".umi",
		"dylib_symlinks": false
	}
	if subDir == "."{
		args["dest_dir"] = RawString{".{ .override = .prefix }"}
	} else {
		args["dest_dir"] = RawString{sprintf(".dest_dir = .{ .override = .{ .custom = %s }},", m.name)}
	}
	m.b.genCall("addInstallArtifact", m.umi, args)
	m.b.gen("b.getInstallStep().dependOn(&os_umi_install.step);")
}

fn __init*(b: ^Build): int {
	b.data = new(BuildData)

	if b.outPath == "" {
		b.data.outFile = std::stdout()
	} else {
		var err: std::Err
		b.data.outFile, err = std::fopen(b.outPath, "w")
		if err.code != 0 {
			return err.code
		}
	}

	b.genHeader()

	return 0
}

fn __deinit*(b: ^Build): int {
	b.genFooter()

	if b.outPath != "" {
		err := std::fclose(b.data.outFile)
		if err.code != 0 {
			return err.code
		}
	}

	return 0
}
